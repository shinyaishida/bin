#!/bin/bash
#
# @(#) Utility to search strings in files interactively.
#
# Copyright (c) 2010 Shinya Ishida. All rights reserved.
#
# Search a keyword in files located in a directory and its subdirectories.
# The search result is printed with file names and line numbers. Additional
# actions, extra search, viewing/editing a file, etc, can be applied to the
# result interactively.
#

readonly ME=$0
readonly MY_BASE=$(basename ${ME})
readonly DEFAULT_DIR=$(pwd)
readonly TMP_PREFIX="/tmp/${MY_BASE}.$$"
readonly TMP_INIT="${TMP_PREFIX}_init"
readonly TMP_FILE1="${TMP_PREFIX}_1"
readonly TMP_FILE2="${TMP_PREFIX}_2"
readonly CMD_PROMPT="command (hit 'h' for help): "
readonly GREP=$(which grep)
readonly IGN_CASE_FLAG='-i'

# Fixed during initalization
SEARCH_DIR="${DEFAULT_DIR}"
SEARCH_PATTERNS=
INIT_SEARCH='-Inr'
CMD_MAP=
CMD_HELP=

# Mutable
IGN_CASE=${IGN_CASE_FLAG}
INPUT=
SEARCH_HISTORY=()
QUICK_UNDO=


function __CleanUp() {
    rm -f ${TMP_PREFIX}* &>/dev/null
}

trap "__CleanUp" 1 2 3 15

function __PrintUsage() {
    cat <<EOF
Usage:
    ${MY_BASE} [options] <pattern>[ <pattern> ...]

Options:
    -c          case-sensitive search
    -d dir      search pattern(s) in the directory
    -x file     exclude file from pattern search
    -X dir      skip pattern search in the directory

Note:
    - If multiple patterns are specified, ${MY_BASE} picks lines containing any
      of the patterns.
    - Binary files are ignored.
    - Multiple '-x' and '-X' options are accepted.
EOF
}

function __ExitWith() {
    local -r IFS='@'
    # Indices of this array are corresponding to exit status values.
    local -r err_msgs=("" $(cat <<EOF | tr '\n' "${IFS}"
no matches
failed in initialization
directory '${SEARCH_DIR}' not found
no patterns specified
failed in first search
command not found
EOF
    ))
    __CleanUp
    case "$1" in
	0)
	    exit 0;;
	[1-9])
	    echo "${err_msgs[$1]}" 1>&2
	    exit $1;;
	*)
	    echo "ERROR: unexpected error" 1>&2
	    exit 127;;
    esac
}

function __GetFirstAvailableCommand() {
    local first=
    for c in $@; do
	which ${c} &>/dev/null && first=${c} && break
    done
    echo -n ${first}
}

readonly steditor=$(__GetFirstAvailableCommand awk gawk)
case ${steditor} in
    awk|gawk)
	function __GetHitCount() {
	    wc -l ${TMP_FILE1} | ${steditor} '{ print $1 }'
	};;
    *)
	function __GetHitCount() {
	    wc -l ${TMP_FILE1} | sed "s/^.*\([0-9]+\).*$/\1/1"
	};;
esac

function __PromptInput() {
    printf "$1" >&2 && read INPUT && [ "$INPUT" ]
}

function __SearchEntries() {
    __PromptInput "pattern:" && \
      local -r search_opt="${IGN_CASE} $@ ${INPUT}" && \
      SEARCH_HISTORY[${#SEARCH_HISTORY[@]}]="${search_opt}" && \
      cat ${TMP_FILE1} > ${TMP_FILE2} && \
      QUICK_UNDO=yes && \
      ${GREP} ${search_opt} ${TMP_FILE2} > ${TMP_FILE1}
}

function __SelectEntry() {
    local -r hit_count=$(__GetHitCount)
    [ ${hit_count} -gt 0 ] && \
      __PromptInput "number (1-${hit_count}):" && \
      [[ ${INPUT} =~ ^[1-9][0-9]*$ ]] && \
      [ ${INPUT} -le ${hit_count} ] && \
      head -${INPUT} ${TMP_FILE1} | tail -1
}

function __GetCaseSensitivity() {
    [ "${IGN_CASE}" ] && echo "case-ignoring" || echo "case-sensitive"
}

function __ToggleCaseSensitivity() {
    IGN_CASE=$([ "${IGN_CASE}" ] && echo "" || echo "${IGN_CASE_FLAG}")
}

function __SetSearchDirectory() {
    SEARCH_DIR=${SEARCH_DIR:-$1}
}

function __ExcludeFiles() {
    INIT_SEARCH=${INIT_SEARCH}${1:+ --exclude=$1}
}

function __ExcludeDirectories() {
    INIT_SEARCH=${INIT_SEARCH}${1:+ --exclude-dir=${1}}
}

function __SetSearchPatterns() {
    for pattern in $@; do
	SEARCH_PATTERNS=${SEARCH_PATTERNS}${pattern:+ -e ${pattern}}
    done
}

function __ConductFirstSearch() {
    ${GREP} ${INIT_SEARCH} ${SEARCH_DIR} > ${TMP_INIT} || __ExitWith 1
    cat ${TMP_INIT} > ${TMP_FILE1}
}

function __RerunSearches() {
    local i=0
    while [ $i -lt ${#SEARCH_HISTORY[@]} ]; do
	cat ${TMP_FILE1} > ${TMP_FILE2}
	${GREP} ${SEARCH_HISTORY[$i]} ${TMP_FILE2} > ${TMP_FILE1}
	((i+=1))
    done
}

readonly printer=$(__GetFirstAvailableCommand more less)
case ${printer} in
    more)
	function __PrintSearchResult() {
	    [ $(__GetHitCount) -gt 0 ] && cat -n ${TMP_FILE1} | more
	    echo "$(__GetHitCount) line(s) matched"
	};;
    less)
	function __PrintSearchResult() {
	    [ $(__GetHitCount) -gt 0 ] && less -N ${TMP_FILE1}
	    echo "$(__GetHitCount) line(s) matched"
	};;
    *)
	function __PrintSearchResult() {
	    [ $(__GetHitCount) -gt 0 ] && cat -n ${TMP_FILE1}
	    echo "$(__GetHitCount) line(s) matched"
	};;
esac

function __PrintCommandList() {
    local -r IFS=''
    (eval echo $(echo ${CMD_HELP} | tr '\n' @)) | tr @ '\n'
}


#
# Command functions
#
# To add a new command, the function must have a comment in the following
# format.  This special comment is parsed by this script itself and registered.
# '@func' is a tag to specify the function's name.  '@key' is a tag to indicate
# an alphabetical letter assigned to call the function via the prompt.  '@desc'
# is a tag for a brief description of the function.  This description is
# printed in the command help.  The note may contain scripts; i.e., variables,
# ${VAR}, and command/function calls, $(command...).  Instead, to print letters
# and strings, which have a special meaning for bash script, as they are, they
# must be quoted with single quotation, like '(' and ')'.
#
# Format:
# # @func FUNCTION_NAME
# # @key K
# # @desc A BRIEF DESCRIPTION OF THE FUNCTION IN A LINE
#
# Note:
# - All tags are required, in the order above, for a function to register.
# - Only a tag can be in a line.
# - A tag line must start with '#'.
# - Only spaces, ' ', may be between the '#' and a tag.

#
# @func PrintSearchResult
# @key p
# @desc print search result
#
function PrintSearchResult() {
    __PrintSearchResult
}

#
# @func SearchEntriesContainingPattern
# @key m
# @desc get lines containing substring matching a specified pattern
#
function SearchEntriesContainingPattern() {
    __SearchEntries
    __PrintSearchResult
}

#
# @func SearchEntriesNotContainingPattern
# @key n
# @desc get lines not containing substring matching a specified pattern
#
function SearchEntriesNotContainingPattern() {
    __SearchEntries -v
    __PrintSearchResult
}

#
# @func UndoSearch
# @key u
# @desc undo last search
#
function UndoSearch() {
    if [ ${#SEARCH_HISTORY[@]} -gt 0 ]; then
      unset SEARCH_HISTORY[$((${#SEARCH_HISTORY[@]} - 1))]
      if [ "${QUICK_UNDO-}" ]; then
	[ -f ${TMP_FILE2} ] && cat ${TMP_FILE2} > ${TMP_FILE1}
	QUICK_UNDO=
      else
	  cat ${TMP_INIT} > ${TMP_FILE1}
	  __RerunSearches
      fi
    fi
    __PrintSearchResult
}

#
# @func RefreshSearch
# @key r
# @desc refresh search result
#
function RefreshSearch() {
    __ConductFirstSearch && __RerunSearches
    __PrintSearchResult
}

#
# @func ViewInFile
# @key v
# @desc view a line with file viewer '('${viewer-not available}')'
#
readonly viewer=$(__GetFirstAvailableCommand less more)
case ${viewer} in
    less)
	function ViewInFile() {
	    read file_name line_num rest < <(__SelectEntry | tr ':' ' ') && \
	      cat -n ${file_name} | less +${line_num}g
	};;
    more)
	function ViewInFile() {
	    read file_name line_num rest < <(__SelectEntry | tr ':' ' ') && \
	      cat -n ${file_name} | more +${line_num}
	};;
    *)
	function ViewInFile() {
	    local -r range=10
	    read file_name line_num rest < <(__SelectEntry | tr ':' ' ') && \
	      cat -n ${file_name} | \
		head -$((${line_num} + ${range})) | \
		tail -$((${range} * 2 + 1))
	};;
esac

#
# @func EditFile
# @key e
# @desc edit a line with text editor '('${editor-not available}')'
#
readonly editor=$(__GetFirstAvailableCommand vi vim)
case ${editor} in
    vi|vim)
	function EditFile() {
	    read file_name line_num rest < <(__SelectEntry | tr ':' ' ') && \
	      ${editor} +${line_num} ${file_name}
	};;
    *)
	function EditFile() {
	    echo "cannot use this function in your environment"
	};;
esac

#
# @func ListFileNames
# @key l
# @desc list file names hit in current search
#
function ListFileNames() {
    cut -d : -f 1 ${TMP_FILE1} | sort -u
}

#
# @func SaveSearchResult
# @key s
# @desc save current result in a file '('overwritten')'
#
function SaveSearchResult() {
    __PromptInput "file:" && cat ${TMP_FILE1} > ${INPUT}
}
readonly SaveSearchResult

#
# @func ToggleCaseSensitivity
# @key c
# @desc toggle case-sensitivity of search '('$(__GetCaseSensitivity) now')'
#
function ToggleCaseSensitivity() {
    __ToggleCaseSensitivity && __GetCaseSensitivity
}

#
# @func ShowHelp
# @key h
# @desc show this help
#
function ShowHelp() {
    __PrintCommandList
}

#
# @func Quit
# @key q
# @desc quit search
#
function Quit() {
    __ExitWith 0
}


#
# Sub-routines
#

# Note: Using associative arrays seems a better choice to implement this
# function.  However, it is supported from bash version 4.  The MacOS's default
# bash (/bin/bash) is version 3.
function __BuildCommandLists() {
    local cmd_docs=$(${GREP} '^# *@' ${ME} | tr '\n' ' ')
    cmd_docs=${cmd_docs//'# '/}
    local IFS=$'\n'
    cmd_docs=(${cmd_docs//@func /$'\n'})
    IFS=' '
    local i=0
    while [ $i -lt ${#cmd_docs[@]} ]; do
	read func_name at_key k at_desc desc < <(echo ${cmd_docs[$i]})
	[ "${func_name}" -a "${desc}" ] && \
	  [ "${at_key}" = "@key" -a "${at_desc}" = "@desc" ] && \
	  [[ "${k}" =~ ^[a-z]$ ]] && {
	      CMD_MAP="${CMD_MAP+${CMD_MAP}$'\n'}${k} ${func_name}"
	      CMD_HELP="${CMD_HELP+${CMD_HELP}$'\n'}  ${k}: ${desc}"
	  }
	((i+=1))
    done
    readonly CMD_MAP=${CMD_MAP}
    readonly CMD_HELP=${CMD_HELP}
}

function __GetCommandFunction() {
    local IFS=''
    ${GREP} "^${INPUT}" <<< ${CMD_MAP} | cut -d ' ' -f 2
}

function __ExecuteCommand() {
    __PromptInput "${CMD_PROMPT}" && {
	local -r cmd_func=$(__GetCommandFunction) || __ExitWith 6
	if [ "${cmd_func}" ]; then
	  ${cmd_func}
	else
	    __PrintCommandList
	fi
    }
}

function __SearchInteractively() {
    while [ x = x ]; do
	__ExecuteCommand
    done
}

##
## Main routine
##

__BuildCommandLists || __ExitWith 2
while getopts "cd:x:X:" flag; do
    case $flag in
	c)
	    __ToggleCaseSensitivity;;
	d)
	    __SetSearchDirectory $OPTARG;;
	x)
	    __ExcludeFiles $OPTARG;;
	X)
	    __ExcludeDirectories $OPTARG;;
	*)
	    __PrintUsage
	    __ExitWith 0;;
    esac
done
shift $(($OPTIND - 1))
__SetSearchPatterns $@
[ -d ${SEARCH_DIR} ] || __ExitWith 3
[ "${SEARCH_PATTERNS-}" ] || __ExitWith 4

# Execute the first search.
readonly INIT_SEARCH=${INIT_SEARCH}" ${IGN_CASE} ${SEARCH_PATTERNS}"
__ConductFirstSearch && {
    __PrintSearchResult
    __SearchInteractively
}
